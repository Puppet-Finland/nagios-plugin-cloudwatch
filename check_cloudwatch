#!/usr/bin/env ruby

require 'aws-sdk-cloudwatch'
require 'yaml'
require 'optparse'

# Convert Cloudwatch metrics in Nagios-plugin compatible format
class CloudWatchMetrics
  # Mapping from Amazon Cloudwatch units to Nagios performance data "unit of
  # measure".  Almost certainly incomplete at this point.
  #
  @@uom = { 'Bytes': { 'perf_data': 'B' },
            'Count': { 'perf_data': '' },
            'Credits': { 'perf_data': 'c' },
            'Percent': { 'perf_data': '%' },
            'Seconds': { 'perf_data': ''  } }

  def initialize(cloudwatch_settings = {})
    @region = cloudwatch_settings[:region]
    @aws_access_key_id = cloudwatch_settings[:aws_access_key_id]
    @aws_secret_access_key = cloudwatch_settings[:aws_secret_access_key]
    @namespace = cloudwatch_settings[:namespace]
    @dimensions = cloudwatch_settings[:dimensions]

    # Convert the keys in the dimensions array to Symbols. This is required by
    # the AWS get_metric_statistics method call. This requires Ruby 2.5 or
    # greater.
    #
    # https://stackoverflow.com/questions/800122/best-way-to-convert-strings-to-symbols-in-hash
    #
    @dimensions.each_with_index do |dimension, index|
      @dimensions[index] = dimension.inject({}) do |memo, (k, v)|
        memo[k.to_sym] = v
        memo
      end
    end

    # Optional parameters
    @precision = if cloudwatch_settings.key?(:precision)
                   cloudwatch_settings[:precision]
                 else
                   2
                 end

    @period = if cloudwatch_settings.key?(:period)
                cloudwatch_settings[:period]
              else
                600
              end

    @debug = if cloudwatch_settings.key?(:debug)
               true
             else
               false
             end

    # The desired metrics
    @desired_metrics = cloudwatch_settings[:metrics]

    # This will get populated by the AWS API calls
    @aws_metric_statistics = {}

    # These are the human readable matric-value pairs also used by the nagios
    # plugin code for graph names and alert messages, as well as alert status
    @nagios_data = {}

    # This stores the aggregate exit status
    #
    # 1: any of the statistics exceeded the critical threshold
    # 2: any of the statistics exceeded the warning threshold
    # 0: all statistics were below the thresholds
    #
    @exit_code = 0

    # Update the AWS settings
    Aws.config.update(
      { region: @region,
        credentials: Aws::Credentials.new(@aws_access_key_id,
                                          @aws_secret_access_key) }
    )

    @client = Aws::CloudWatch::Client.new(region: @region)
  end

  def flattened_metric_statistics(metric_statistics)
    flattened_metric_statistics = metric_statistics.clone

    metric_statistics.each_with_index do |statistic, index|
      if statistic.is_a?(Hash)
        flattened_metric_statistics[index] = statistic.keys[0]
      end
    end
    flattened_metric_statistics
  end

  def populate_metrics
    # Some metrics like RDS BurstBalance do not provide _any_ datapoints unless
    # we substract a considerable amount of seconds from the start_time.
    base_parameters = { namespace: @namespace,
                        dimensions: @dimensions,
                        start_time: Time.now - @period - 120,
                        end_time: Time.now,
                        period: @period }

    @desired_metrics.each_pair do |metric_id, metric|
      metric_name = metric['metric_name']
      metric_statistics = metric['statistics']
      metric_unit = metric['unit']

      if @debug
        puts "Metric ID: #{metric_id}"
        puts "  Metric name: #{metric_name}"
        puts "  Metric unit: #{metric_unit}"
        puts "  Metric statistics: #{metric_statistics}"
        puts
      end

      # If a statistic (e.g. "average") has children then we must flatten it
      # for the AWS API call. We need those children entries for the optional
      # alert thresholds
      flattened_metric_statistics = self.flattened_metric_statistics(metric_statistics)

      metric_hash = { metric_name: metric['metric_name'],
                      unit: metric['unit'],
                      statistics: flattened_metric_statistics }

      params = base_parameters.merge(metric_hash)
      stat = @client.get_metric_statistics(params)

      @aws_metric_statistics[metric_id] = stat

      if @debug
        puts "  AWS API call returns: #{@aws_metric_statistics}"
        puts
      end

      metric_statistics.each do |statistic|
        if @debug
          puts "  Statistic: #{statistic}"
          puts
        end

        statistic_name =  if statistic.is_a?(Hash)
                            statistic.keys[0]
                          else
                            statistic
                          end

        aws_stat = statistic_name.downcase
        value = @aws_metric_statistics[metric_id][:datapoints][0][aws_stat]
        nagios_metric_name = "#{metric_id}_#{statistic_name}_#{metric_unit}"
        nagios_metric_name.downcase!

        @nagios_data[nagios_metric_name] = {}
        @nagios_data[nagios_metric_name][:value] = value
        # Convert AWS style units to Nagios style
        uom = @@uom[metric_unit.to_sym][:perf_data]
        @nagios_data[nagios_metric_name][:uom] = uom
        # Only metrics that are hashes in the yaml file have warning or
        # critical thresholds.
        #
        # - Set warning and critical thresholds for use in the performance data
        # - Set warning and critical status for metrics
        # - Sets the exit code if any warnings or critical issues are found
        #
        if statistic.is_a?(Hash)
          warn = statistic[statistic_name]['warn_threshold']
          crit = statistic[statistic_name]['critical_threshold']

          if statistic.is_a?(Hash)
            @nagios_data[nagios_metric_name][:warn_threshold] = warn
            @nagios_data[nagios_metric_name][:critical_threshold] = crit
          end

          if @nagios_data[nagios_metric_name][:value] > crit
            @nagios_data[nagios_metric_name][:critical] = true
            @exit_code = 2
          elsif @nagios_data[nagios_metric_name][:value] > warn
            @nagios_data[nagios_metric_name][:warning] = true

            # If we already have a critical problem we don't want to override
            # it with a warning exit code
            @exit_code = 1 unless @exit_code == 2
          end
        end

        if @debug
          puts "    Value #{statistic_name}: #{value}"
          puts
        end
      end
    end

    return unless @debug

    puts '@nagios_data:'
    puts @nagios_data
    puts
  end

  # Get the "human readable" first part of Nagios plugin output
  def service_output
    "#{@namespace} #{@dimensions[0][:value]} #{nagios_issues_to_s}"
  end

  # Get the optional performance data that follows the human readable part.
  # Format documented here:
  #
  # <https://nagios-plugins.org/doc/guidelines.html#AEN200>
  #
  # We do not use "min" or "max"
  #
  def service_perf_data
    output = ''
    @nagios_data.each do |statistic, data|
      stat = "#{statistic}=#{data[:value].round(@precision)}"
      warn = data[:warn_threshold]
      crit = data[:critical_threshold]
      output << "#{stat}#{data[:uom]};#{warn};#{crit};; "
    end
    output.chomp(' ')
  end

  def puts_and_exit
    puts "#{service_output} | #{service_perf_data}"
    exit(@exit_code)
  end

  # Convert the nagios_issues has into a printable string
  def nagios_issues_to_s
    nagios_issues = ''
    @nagios_data.each do |statistic, data|
      if data[:warning] || data[:critical]
        stat = "#{statistic}=#{data[:value].round(@precision)}"
        thres = data[:warn_threshold]
      end

      if data[:warning]
        nagios_issues << "WARNING: #{stat} exceeds the threshold of #{thres}!"
      end

      if data[:critical]
        nagios_issues << "CRITICAL: #{stat} exceeds the threshold of #{thres}!"
      end
    end

    if nagios_issues.empty?
      'OK'
    else
      nagios_issues.chomp(' ')
    end
  end
end

### Main program

# Parse command-line options
options = {}

optparse = OptionParser.new do |opts|
  opts.banner = 'Usage: check_cloudwatch -c config_file [-d]'
  opts.on('-c', '--config file', 'Path to the config file') do |file|
    options[:config_file] = file
  end
  opts.on('-d', '--debug', 'Print debugging information') do
    options[:debug] = true
  end
  opts.on('-H', '--host host', 'For nagios compatibility')
  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end

optparse.parse!

begin
  config = YAML.load_file(options[:config_file])
rescue Errno::ENOENT
  puts "ERROR: config file #{options[:config_file]} not found!"
  exit 1
end

# Mandatory settings
cloudwatch_settings = {
  region: config['defaults']['region'],
  aws_access_key_id: config['defaults']['aws_access_key_id'],
  aws_secret_access_key: config['defaults']['aws_secret_access_key'],
  namespace: config['defaults']['namespace'],
  dimensions: config['defaults']['dimensions'],
  metrics: config['defaults']['metrics']
}

# Optional settings: rounding precision (default 3) and time period (default
# 600 seconds)
if config['defaults'].key?('precision')
  cloudwatch_settings.merge!(precision: config['defaults']['precision'])
end

if config['defaults'].key?('period')
  cloudwatch_settings.merge!(period: config['defaults']['period'])
end

cloudwatch_settings.merge!(debug: true) if options[:debug]
cloudwatch = CloudWatchMetrics.new(cloudwatch_settings)

cloudwatch.populate_metrics
cloudwatch.puts_and_exit
