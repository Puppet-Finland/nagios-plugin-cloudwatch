#!/usr/bin/env ruby

require 'aws-sdk-cloudwatch'
require 'yaml'
require 'optparse'

class CloudWatchMetrics

  # Mapping from Amazon Cloudwatch units to Nagios performance data "unit of
  # measure".  Almost certainly incomplete at this point.
  #
  @@uom = { 'Bytes':   { 'perf_data': 'B' },
            'Count':   { 'perf_data': '' },
            'Credits': { 'perf_data': 'c' },
            'Percent': { 'perf_data': '%' },
            'Seconds': { 'perf_data': ''  }, }

  def initialize(cloudwatch_settings = {})
    @region = cloudwatch_settings[:region]
    @aws_access_key_id = cloudwatch_settings[:aws_access_key_id]
    @aws_secret_access_key = cloudwatch_settings[:aws_secret_access_key]
    @namespace = cloudwatch_settings[:namespace]
    @dimensions = cloudwatch_settings[:dimensions]

    # Convert the keys in the dimensions array to Symbols. This is required by
    # the AWS get_metric_statistics method call. This requires Ruby 2.5 or
    # greater.
    #
    # https://stackoverflow.com/questions/800122/best-way-to-convert-strings-to-symbols-in-hash
    #
    @dimensions.each_with_index do |dimension, index|
      @dimensions[index] = dimension.inject({}){|memo,(k,v)| memo[k.to_sym] = v; memo}
    end

    # Optional parameters
    cloudwatch_settings.has_key?(:precision) ? @precision = cloudwatch_settings[:precision] : @precision = 2
    cloudwatch_settings.has_key?(:period) ? @period = cloudwatch_settings[:period] : @period = 600
    cloudwatch_settings.has_key?(:debug) ? @debug = true : @debug = false

    # The desired metrics
    @desired_metrics = cloudwatch_settings[:metrics]

    # This will get populated by the AWS API calls
    @aws_metric_statistics = {}

    # These are the human readable matric-value pairs also used by the nagios
    # plugin code for graph names and alert messages, as well as alert status
    @nagios_data = {}

    # This stores the aggregate exit status
    # 
    # 1: any of the statistics exceeded the critical threshold
    # 2: any of the statistics exceeded the warning threshold
    # 0: all statistics were below the thresholds
    #
    @exit_code = 0

    # Update the AWS settings
    Aws.config.update({ region: @region,
                        credentials: Aws::Credentials.new(@aws_access_key_id, @aws_secret_access_key)
                      })

    @client = Aws::CloudWatch::Client.new(region: @region)
  end

  def get_flattened_metric_statistics(metric_statistics)
      flattened_metric_statistics = metric_statistics.clone

      metric_statistics.each_with_index do |statistic, index|
        flattened_metric_statistics[index] = statistic.keys[0] if statistic.is_a?(Hash)
      end
      flattened_metric_statistics
  end

  def populate_metrics
    base_parameters = { namespace: @namespace,
                        dimensions: @dimensions,
                        start_time: Time.now - @period,
                        end_time: Time.now,
                        period: @period
                      }

    @desired_metrics.each_pair do |metric_id, metric|
      metric_name = metric['metric_name']
      metric_statistics = metric['statistics']
      metric_unit = metric['unit']

      if @debug
        puts "Metric ID: #{metric_id}"
        puts "  Metric name: #{metric_name}"
        puts "  Metric unit: #{metric_unit}"
        puts "  Metric statistics: #{metric_statistics}"
        puts
      end

      # If a statistic (e.g. "average") has children then we must flatten it
      # for the AWS API call. We need those children entries for the optional
      # alert thresholds
      flattened_metric_statistics = self.get_flattened_metric_statistics(metric_statistics)

      @aws_metric_statistics[metric_id] = @client.get_metric_statistics(params=base_parameters.merge(metric_name:  metric['metric_name'],
                                                                                                     unit:         metric['unit'],
                                                                                                     statistics:   flattened_metric_statistics))
      if @debug
        puts "  AWS API call returns: #{@aws_metric_statistics}"
        puts
      end

      metric_statistics.each do |statistic|

        if @debug
          puts "  Statistic: #{statistic}"
          puts
        end

        if statistic.is_a?(Hash)
          statistic_name = statistic.keys[0]
        else
          statistic_name = statistic
        end

        value = @aws_metric_statistics[metric_id][:datapoints][0][statistic_name.downcase]
        nagios_metric_name = "#{metric_id}_#{statistic_name}_#{metric_unit}".downcase

        @nagios_data[nagios_metric_name] = {}
        @nagios_data[nagios_metric_name][:value] = value
        # Convert AWS style units to Nagios style
        @nagios_data[nagios_metric_name][:uom] = @@uom[metric_unit.to_sym][:perf_data]

        # Only metrics that are hashes in the yaml file have warning or critical thresholds.
        #
        # - Set warning and critical thresholds for use in the performance data
        # - Set warning and critical status for metrics
        # - Sets the exit code if any warnings or critical issues are found
        #
        if statistic.is_a?(Hash)
          warn_threshold = statistic[statistic_name]['warn_threshold']
          critical_threshold = statistic[statistic_name]['critical_threshold']

          @nagios_data[nagios_metric_name][:warn_threshold] = warn_threshold if statistic.is_a?(Hash)
          @nagios_data[nagios_metric_name][:critical_threshold] = critical_threshold if statistic.is_a?(Hash)

          if @nagios_data[nagios_metric_name][:value] > critical_threshold
            @nagios_data[nagios_metric_name][:critical] = true
            @exit_code = 1
          elsif @nagios_data[nagios_metric_name][:value] > warn_threshold
            @nagios_data[nagios_metric_name][:warning] = true

            # If we already have a critical problem we don't want to override
            # it with a warning exit code
            @exit_code = 2 unless @exit_code == 1
          end
        end

        if @debug
          puts "    Value #{statistic_name}: #{value}"
          puts
        end
      end
    end

    if @debug
      puts "@nagios_data:"
      puts @nagios_data
      puts
    end
  end

  # Get the "human readable" first part of Nagios plugin output
  def get_service_output
    "#{@namespace} #{@dimensions[0][:value]} #{self.nagios_issues_to_s}"
  end

  # Get the optional performance data that follows the human readable part. Format documented here:
  #
  # <https://nagios-plugins.org/doc/guidelines.html#AEN200>
  #
  # We do not use "min" or "max"
  #
  def get_service_perf_data
    output = ""
    @nagios_data.each do |statistic, data|
      output << "#{statistic}=#{data[:value].round(@precision)}#{data[:uom]};#{data[:warn_threshold]};#{data[:critical_threshold]};; "
    end
    output.chomp(' ')
  end

  def puts_and_exit
    puts "#{self.get_service_output} | #{self.get_service_perf_data}"
    exit(@exit_code)
  end

  # Convert the nagios_issues has into a printable string
  def nagios_issues_to_s
    nagios_issues = ""
    @nagios_data.each do |statistic, data|
      nagios_issues << "WARNING: #{statistic}=#{data[:value].round(@precision)} exceeds the threshold of #{data[:warn_threshold]}! " if data[:warning]
      nagios_issues << "CRITICAL: #{statistic}=#{data[:value].round(@precision)} exceeds the threshold of #{data[:warn_threshold]}! " if data[:critical]
    end

    if nagios_issues.empty?
      "OK"
    else
      nagios_issues.chomp(' ')
    end
  end
end

### Main program

# Parse command-line options
options = {}

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: check_rds -c config_file [-d]"
  opts.on( '-c', '--config file', 'Path to the config file' ) do |file|
    options[:config_file] = file
  end
  opts.on( '-d', '--debug', 'Print debugging information' ) do
    options[:debug] = true
  end
  opts.on( '-H', '--host host', 'For nagios compatibility' )
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

optparse.parse!

begin
  config = YAML.load_file(options[:config_file])
rescue Errno::ENOENT
  puts "ERROR: config file #{options[:config_file]} not found!"
  exit 1
end

# Mandatory settings
cloudwatch_settings = { region: config['defaults']['region'],
                        aws_access_key_id: config['defaults']['aws_access_key_id'],
                        aws_secret_access_key: config['defaults']['aws_secret_access_key'],
                        namespace: config['defaults']['namespace'],
                        dimensions: config['defaults']['dimensions'],
                        metrics: config['defaults']['metrics'] }

# Optional settings: rounding precision (default 3) and time period (default 600 seconds)
cloudwatch_settings.merge!(precision: config['defaults']['precision']) if config['defaults'].has_key?('precision')
cloudwatch_settings.merge!(period: config['defaults']['period']) if config['defaults'].has_key?('period')
cloudwatch_settings.merge!(debug: true) if options[:debug]
cloudwatch = CloudWatchMetrics.new(cloudwatch_settings)

cloudwatch.populate_metrics
cloudwatch.puts_and_exit
